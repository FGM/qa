<?php
// $Id$
/**
 * @file
 * OSInet Quality Assurance module for Drupal
 *
 * @copyright Copyright (C) 2005-2011 Frederic G. MARAND for Ouest SystÃ¨mes Informatiques (OSInet)
 *
 * @since DRUPAL-4-6
 *
 * @license Licensed under the disjunction of the CeCILL, version 2 and General Public License version 2 and later
 *
 * License note: QA is distributed by OSInet to its customers under the
 * CeCILL 2.0 license. OSInet support services only apply to the module
 * when distributed by OSInet, not by any third-party further down the
 * distribution chain.
 *
 * If you obtained QA from drupal.org, that site received it under the
 * GPLv2 license and can therefore distribute it under the GPLv2, and
 * so can you and just anyone down the chain as long as the GPLv2 terms
 * are abided by, the module distributor in that case being the
 * drupal.org organization or the downstream distributor, not OSInet.
 */

/**
 * A lifetime class
 *
 * Properties are: Start, Access, Modify, End
 *
 *
 * WARNING: SAME is an old (ca 2005) OSInet library class, which other modules
 * may have imported. Older versions should be removed.
 */
class Same {
  public $s;
  public $a;
  public $m;
  public $e;

  /**
   * Constructor
   *
   * S.A.M. default to current time, but E has no default.
   *
   * @param int $s
   * @param int $a
   * @param int $m
   * @param int $e
   */
  function __construct($s = NULL, $a = NULL, $m = NULL, $e = NULL) {
    $now = time();
    foreach (array('s', 'a', 'm') as $ts) {
      $this->$ts = isset($$ts) ? $$ts : $now;
    }
  }

  public function access($now = NULL) {
    $this->a = isset($now) ? $now : time();
  }

  public function modify($now = NULL) {
    if (!isset($now)) {
      $now = time();
    }
    $this->access($now);
    $this->m = $now;
  }

  public function end($now = NULL) {
    if (!isset($now)) {
      $now = time();
    }
    $this->modify($now);
    $this->e = $now;
  }
}


abstract class QaExportable {
  /**
   * Machine name
   *
   * @var string
   */
  public $name;

  /**
   * Description: translatable
   *
   * @var string
   */
  public $description;

  /**
   * Human readable name, used for titles. Translatable.
   *
   * @var string
   */
  public $title;

  /**
   * Singleton protected constructor
   *
   * @param string $name
   */
  protected function __construct() {
    $this->name = get_called_class();
  }
}

/**
 * An instantiable QaExportable
 */
abstract class QaPackage extends QaExportable {

  protected static $instances = array();

  public static function getInstance() {
    $name = get_called_class();
    if (!isset(self::$instances[$name])) {
      self::$instances[$name] = new $name();;
    }
    return self::$instances[$name];
  }
}

abstract class QaControl extends QaExportable {

  /**
   * The package to which the control belongs
   *
   * @var string
   */
  public $package_name;

  /**
   * An options hash
   *
   * @var array
   */
  public $options;

  /**
   * The hash of passes for that control.
   *
   * @var array
   */
  public $passes;

  /**
   * Singleton-per-child-class data holder.
   *
   * @var array
   */
  protected static $instances = array();

  /**
   * Per-package list of instances
   *
   * @var array
   */
  protected static $packages = array();

  /**
   * Return an array of module dependencies.
   *
   * @return array
   */
  public static function getDependencies() {
    return array();
  }

  public static function getInstance() {
    $name = get_called_class();
    if (!isset(self::$instances[$name])) {
      $instance = new $name();
      self::$instances[$name] = $instance;
      if (!isset(self::$packages[$instance->package_name])) {
        $package = new $instance->package_name();
        self::$packages[get_class($package)] = array(
          'package' => $package,
          'controls' => array(),
        );
      }
      self::$packages[$instance->package_name]['controls'][$instance->name] = $instance;
    }
    $ret = self::$instances[$name];
    return $ret;
  }

  /**
   * Returns per-package controls.
   *
   * @param string $package_name
   *   If given, only return the list of controls belonging to that package
   *
   * @return array
   *   - if $package_name is given, an array of control instances
   *   - else a package-name-indexed hash of arrays of control instances
   */
  public static function getControls($package_name = NULL) {
    if (isset($package_name)) {
      $ret = isset(self::$packages[$package_name])
        ? self::$packages[$package_name]
        : NULL;
    }
    else {
      $ret = self::$packages;
    }
    return $ret;
  }

  /**
   * Run the control.
   *
   * @return int
   *   - 0: failure
   *   - 1: success
   */
  public function run() {
    $key = uniqid(variable_get('site_key', NULL));
    $pass = new QaPass($this);
    $this->passes[$key] = $pass;
    return $pass;
  }

}

/**
 * A control pass.
 */
class QaPass {
  /**
   * The control of which this is a pass
   *
   * @var QaControl
   */
  public $control;

  /**
   * The user who ran the pass.
   *
   * This is normally a stdClass with a $uid public member.
   *
   * @var object
   */
  public $account;

  /**
   * The pass lifecycle
   *
   * @var Same
   */
  public $life;

  /**
   * Success or failure
   *
   * @var int
   *   - NULL: undefined
   *   - 0: failure
   *   - 1: success
   */
  public $status;

  /**
   * Render array for the results
   *
   * @param array
   */
  public $result;

  function __construct($control) {
    $this->life = new Same();
    $this->status = NULL;
    $this->control = $control;
    $this->account = $GLOBALS['user'];
    $this->result = array();
  }

  /**
   * Record results from one of the checks in a control pass
   *
   * @param array $check
   *   - status: 0 or 1
   *   - result: render array
   *
   * @return void
   */
  function record($check) {
    if (!$check['status']) {
      $this->status = 0;
      if (isset($check['name'])) {
        $this->result[$check['name']] = $check['result'];
      }
      else {
        $this->result[] = $check['result'];
      }
    }
    elseif (!isset($this->status)) {
      $this->status = 1;
    }
    $this->life->modify();
  }
}

function qa_init() {
  drupal_add_css(drupal_get_path('module', 'qa') .'/qa.css');
}

/**
 * Implements hook_menu().
 */
function qa_menu() {
  $items = array();
  $items['admin/reports/qa'] = array(
    'title'           => 'Quality Assurance',
    'page callback'   => 'drupal_get_form',
    'page arguments'  => array('qa_report_form'),
    'access callback' => 'qa_report_access',
  );
  $items['admin/reports/qa/results'] = array(
    'title'           => 'Quality Assurance results',
    'page callback'   => 'qa_report_results',
    'page arguments'  => array(),
    'access callback' => 'qa_report_access',
    'type'            => MENU_CALLBACK,
  );

  $items['dependencies'] = array(
    'title' => 'Package dependencies',
    'page callback' => 'qa_page_dependencies',
    'access callback' => 'module_exists',
    'access arguments' => array('graphviz_filter'),
    'file' => 'qa_dependencies.inc',
  );
  return $items;
}

function qa_page_dependencies() {
  return graphviz_filter_render(qa_dependencies());
}

/**
 * Access callback for QA reports.
 */
function qa_report_access() {
  global $user;
  return isset($user->uid) && $user->uid == 1;
}

function qa_report_finished($success, $results, $operations) {
  unset($results['#message']);
  if ($success) {
    $message = format_plural(count($results), 'One control pass ran.', '@count control passes ran.');
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);
  $_SESSION['qa_results'] = $results;
  drupal_goto('admin/reports/qa/results');
}

/**
 * Results page for QA Controls batch.
 *
 * @link http://www.php.net/manual/fr/function.unserialize.php @endlink
 */
function qa_report_results() {
  if (empty($_SESSION['qa_results'])) {
    drupal_goto('admin/reports/qa');
  }
  // Work around incomplete classes
  $results = unserialize(serialize($_SESSION['qa_results']));

  $header = array(
    t('Control'),
    t('Status'),
    t('Results'),
  );
  $data = array();
  foreach ($results as $class_name => $pass) {
    $control = $pass->control;
    $data[] = array(
      $control->title,
      $pass->status
        ? theme('image', 'misc/watchdog-ok.png',    t('OK'))
        : theme('image', 'misc/watchdog-error.png', t('Error')),
      $pass->result,
    );
  }

  $ret = theme('table', $header, $data, array('id' => 'qa-results'));
  // unset($_SESSION['qa_results']);
  return $ret;
}

/**
 * Form builder for QA packages/controls selection form.
 *
 * @return array
 */
function qa_report_form($form_state) {

  $form = array();
  _qa_setup(); // initialize list
  $packages = QaControl::getControls();
  ksort($packages);

  foreach ($packages as $package_name => $package_info) {
    $collapsed = TRUE;
    $form[$package_name] = array(
      '#type' => 'fieldset',
      '#title' => $package_info['package']->title,
      '#description' => $package_info['package']->description,
      '#collapsible' => TRUE,
    );
    foreach ($package_info['controls'] as $control_name => $control) {
      $default_value = isset($_SESSION[$control_name]) ? $_SESSION[$control_name] : NULL;
      if ($default_value) {
        $collapsed = FALSE;
      }

      $deps = array();
      $met = TRUE;
      foreach ($control->getDependencies() as $dep_name) {
        if (module_exists($dep_name)) {
          $deps[] = t('@module (<span class="admin-enabled">available</span>)', array('@module' => $dep_name));
        }
        else {
          $deps[] = t('@module (<span class="admin-disabled">unavailable</span>)', array('@module' => $dep_name));
          $met = FALSE;
        }
      }
      $form[$package_name][$control_name] = array(
        '#type'          => 'checkbox',
        '#default_value' => $met ? $default_value : 0,
        '#title'         => $control->title,
        '#description'   => $control->description,
        '#disabled'      => !$met,
      );
      $form[$package_name][$control_name .'-dependencies'] = array(
        '#value' => t('Depends on: !dependencies', array('!dependencies' => implode(', ', $deps))),
        '#prefix' => '<div class="admin-dependencies">',
        '#suffix' => '</div>',
      );
    }
    $form[$package_name]['#collapsed'] = $collapsed;
  }

  $form['submit'] = array(
    '#type'  => 'submit',
    '#value' => t('Run controls'),
  );
  return $form;
}

/**
 * Submit handler for QA packages/controls selection form
 *
 * @param array $form
 * @param array $form_state
 */
function qa_report_form_submit($form, &$form_state) {
  $controls = array();
  foreach ($form_state['values'] as $item => $value) {
    if (class_exists($item) && is_subclass_of($item, 'QaControl')) {
      if ($value) {
        $controls[$item] = $value;
      }
      $_SESSION[$item] = $value;
    }
  }
  // drupal_set_message(t('Prepare to run these controls: @controls', array('@controls' => implode(', ', array_keys($controls)))));
  $batch = array(
    'operations'       => array(),
    'title'            => t('QA Controls running'),
    'init_message'     => t('QA Controls initializing'),
    // 'progress_message' => t('current: @current, Remaining: @remaining, Total: @total'),
    'error_message'    => t('Error in QA Control'),
    'finished'         => 'qa_report_finished',
    // 'file'             => '', // only if outside module file
  );

  foreach ($controls as $item => $value) {
    $batch['operations'][] = array('qa_report_run_pass', array($item));
  }
  batch_set($batch);
}

/**
 * Batch progress step.
 *
 * @return void
 */
function qa_report_run_pass($class_name, &$context) {
  $name_arg = array('@class' => $class_name);

  $lookup = autoload_get_lookup();
  $file = $lookup[$class_name];
  $control = call_user_func(array($class_name, 'getInstance'));

  if (!is_object($control)) {
    drupal_set_message(t('Cannot obtain an instance for @class', $name_arg), 'error');
    $context['results']['#message'] = t('Control @name failed to run.', $name_arg);
    $context['message'] = t('Control @name failed to run.', $name_arg);
    $context['results'][$class_name] = 'wow';
  }
  else {
    // drupal_set_message(t('Running an instance for @class', $name_arg), 'status');
    $pass = $control->run();
    if (!$pass->status) {
      $context['success'] = FALSE;
    }
    $context['results']['#message'][] = t('Control @name ran', array('@name' => $class_name));
    $context['message'] = theme('item_list', $context['results']['#message']);
    $context['results'][$class_name] = $pass;
  }
}

/**
 * Initialize the object set.
 *
 * To find the control classes, get_declared_classes() is useless: most of these
 * classes are unlikely to be loaded yet. The Autoload registry, on the other
 * hand, is available, since qa_requirements() made sure it was.
 *
 * As a fallback, we also invoke hook_autoload_info() to support modules designed for autoload 6.1
 * in order to complete the list.
 *
 * @return void
 */
function _qa_setup() {
  // if autoload 6.x-2.x
  if (db_table_exists('autoload_registry')) {
    $sq = "SELECT ar.name FROM {autoload_registry} ar WHERE type='class'";
    $q = db_query($sq);
    while ($o = db_fetch_object($q)) {
      $classes[$o->name] = $o->name;
    }
  }
  else { // autoload 6.x-1.x
    $autoload61_classes = module_invoke_all('autoload_info');
    foreach ($autoload61_classes as $name => $info) {
      $classes[$name] = $name;
    }
  }

  foreach (array_keys($classes) as $name) {
    $rc = new ReflectionClass($name);
    if (!$rc->isAbstract() && is_subclass_of($name, 'QaControl')) {
      // Instantiate classes to register them and their packages
      call_user_func(array($name, 'getInstance'));
    }
  }

}

/**
 * Implements hook_autoload_info().
 *
 * Provide a fallback mechanism for sites not using autoload 6.2
 */
function qa_autoload_info() {
  $sq = "SELECT s.info FROM {system} s WHERE s.name = 'qa'";
  $info = db_result(db_query_range($sq, 0, 1));
  $info = unserialize($info);
  $files = $info['files'];
  $path = drupal_get_path('module', 'qa');
  $prev = get_declared_classes();
  $ret = array();
  foreach ($files as $file) {
    require_once $path .'/'. $file;
    $new = get_declared_classes();
    $diff = array_diff($new, $prev);
    foreach ($diff as $class) {
      $ret[$class] = array(
        'file' => basename($file),
        'file path' => $path .'/'. dirname($file),
      );
    }
    $prev = $new;
  }

  return $ret;
}
